name: QC Plan Bot - Automated Checks

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  pull_request_review:
    types: [submitted]

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: write

jobs:
  qc-plan-automated-checks:
    name: QC Plan Automated Validation
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Level 1 - Peer Review Bot
        id: level1-bot
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            
            // Check for approvals
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const approvals = reviews.data.filter(r => r.state === 'APPROVED');
            const hasApproval = approvals.length > 0;
            const latestApproval = approvals.length > 0 ? approvals[approvals.length - 1] : null;
            
            // Check for unresolved comments
            const reviewComments = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const unresolvedComments = reviewComments.data.filter(c => !c.in_reply_to_id && c.state !== 'RESOLVED');
            
            // Check CI status
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const status = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.data.head.sha,
            });
            
            const allChecksPassed = status.data.state === 'success';
            
            const level1Status = {
              '1.1': hasApproval,
              '1.2': hasApproval && unresolvedComments.length === 0,
              '1.3': allChecksPassed,
              reviewer: latestApproval ? latestApproval.user.login : null,
              reviewDate: latestApproval ? latestApproval.submitted_at : null
            };
            
            core.setOutput('level1_status', JSON.stringify(level1Status));
            
            // Post status comment
            const comment = `## ü§ñ QC Plan Bot - Level 1: Peer Review

| Check | Status | Details |
|-------|--------|---------|
| **1.1** Code reviewed | ${hasApproval ? '‚úÖ' : '‚è≥'} | ${hasApproval ? `Approved by @${latestApproval.user.login}` : 'Waiting for approval'} |
| **1.2** Comments resolved | ${hasApproval && unresolvedComments.length === 0 ? '‚úÖ' : '‚è≥'} | ${unresolvedComments.length > 0 ? `${unresolvedComments.length} unresolved comments` : 'All resolved'} |
| **1.3** Coding standards | ${allChecksPassed ? '‚úÖ' : '‚è≥'} | ${allChecksPassed ? 'All checks passed' : 'Some checks pending'} |

${hasApproval && unresolvedComments.length === 0 && allChecksPassed ? '‚úÖ **Level 1 Complete**' : '‚è≥ **Level 1 In Progress**'}

---
*Automated by QC Plan Bot*`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });

      - name: Level 2 - QA Certification Bot
        id: level2-bot
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            
            // Check if deployed to staging
            const deployments = await github.rest.repos.listDeployments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.ref,
            });
            
            const hasStagingDeployment = deployments.data.length > 0;
            
            // Check test status
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const status = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.data.head.sha,
            });
            
            const testChecks = status.data.statuses.filter(s => 
              s.context.includes('test') || s.context.includes('e2e')
            );
            const allTestsPassed = testChecks.every(t => t.state === 'success') && testChecks.length > 0;
            
            const level2Status = {
              '2.1': hasStagingDeployment,
              '2.2': allTestsPassed,
              '2.3': true, // Manual check needed
              '2.4': true, // Manual check needed
              '2.5': allTestsPassed
            };
            
            core.setOutput('level2_status', JSON.stringify(level2Status));
            
            const comment = `## ü§ñ QC Plan Bot - Level 2: QA Certification

| Check | Status | Details |
|-------|--------|---------|
| **2.1** Staging deployment | ${hasStagingDeployment ? '‚úÖ' : '‚è≥'} | ${hasStagingDeployment ? 'Deployed' : 'Pending deployment'} |
| **2.2** Test execution | ${allTestsPassed ? '‚úÖ' : '‚è≥'} | ${allTestsPassed ? 'All tests passed' : 'Tests pending'} |
| **2.3** No critical bugs | ‚è≥ | Manual verification needed |
| **2.4** Known issues listed | ‚è≥ | Manual verification needed |
| **2.5** Regression testing | ${allTestsPassed ? '‚úÖ' : '‚è≥'} | ${allTestsPassed ? 'E2E tests passed' : 'Pending'} |

${hasStagingDeployment && allTestsPassed ? '‚úÖ **Level 2 Automated Checks Complete**' : '‚è≥ **Level 2 In Progress**'}

---
*Automated by QC Plan Bot*`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });

      - name: Update PR Status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const level1 = JSON.parse('${{ steps.level1-bot.outputs.level1_status }}');
            const level2 = JSON.parse('${{ steps.level2-bot.outputs.level2_status }}');
            
            const level1Complete = level1['1.1'] && level1['1.2'] && level1['1.3'];
            const level2Complete = level2['2.1'] && level2['2.2'] && level2['2.5'];
            
            // Create check run
            const checkRun = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'QC Plan Compliance',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: level1Complete && level2Complete ? 'success' : 'neutral',
              output: {
                title: 'QC Plan Automated Checks',
                summary: `**Level 1 (Peer Review)**: ${level1Complete ? '‚úÖ Complete' : '‚è≥ In Progress'}\n**Level 2 (QA Certification)**: ${level2Complete ? '‚úÖ Complete' : '‚è≥ In Progress'}`,
                text: `### Level 1: Peer Review\n- 1.1 Code reviewed: ${level1['1.1'] ? '‚úÖ' : '‚ùå'}\n- 1.2 Comments resolved: ${level1['1.2'] ? '‚úÖ' : '‚ùå'}\n- 1.3 Coding standards: ${level1['1.3'] ? '‚úÖ' : '‚ùå'}\n\n### Level 2: QA Certification\n- 2.1 Staging deployment: ${level2['2.1'] ? '‚úÖ' : '‚ùå'}\n- 2.2 Test execution: ${level2['2.2'] ? '‚úÖ' : '‚ùå'}\n- 2.5 Regression testing: ${level2['2.5'] ? '‚úÖ' : '‚ùå'}`
              }
            });
            
            console.log(`‚úÖ Created check run: ${checkRun.data.id}`);

