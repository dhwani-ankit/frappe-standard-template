name: DevOps Checklist Bot

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  pull_request_review:
    types: [submitted, dismissed]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["Staging Deployment", "E2E Tests", "CI"]
    types: [completed]
  deployment_status:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR Number'
        required: true
        type: string

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: read
  deployments: read

jobs:
  devops-checklist:
    name: DevOps Checklist Bot
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Gather DevOps Status
        id: devops-status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request?.number || 
                            (context.payload.inputs?.pr_number ? parseInt(context.payload.inputs.pr_number) : null);
            
            if (!prNumber) {
              core.setFailed('PR number not found');
              return;
            }
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            // Check CI/CD status
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.data.head.sha,
            });
            
            const ciChecks = checks.data.check_runs.filter(check => 
              check.name.includes('CI') || 
              check.name.includes('Build') ||
              check.name.includes('Test') ||
              check.name.includes('Lint')
            );
            
            const allCIPassed = ciChecks.length > 0 && ciChecks.every(c => 
              c.status === 'completed' && c.conclusion === 'success'
            );
            
            // Check deployment status
            const deployments = await github.rest.repos.listDeployments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.data.head.ref,
            });
            
            const stagingDeployment = deployments.data.find(d => 
              d.environment === 'staging' || d.environment === 'uat'
            );
            
            // Check if staging deployment succeeded
            let stagingDeployed = false;
            if (stagingDeployment) {
              const statuses = await github.rest.repos.listDeploymentStatuses({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: stagingDeployment.id,
              });
              stagingDeployed = statuses.data.some(s => s.state === 'success');
            }
            
            // Check security scans
            const securityChecks = checks.data.check_runs.filter(check => 
              check.name.includes('Security') ||
              check.name.includes('Vulnerability') ||
              check.name.includes('Bandit') ||
              check.name.includes('Safety')
            );
            
            const securityPassed = securityChecks.length === 0 || securityChecks.every(c => 
              c.status === 'completed' && c.conclusion === 'success'
            );
            
            // Check code coverage
            const coverageChecks = checks.data.check_runs.filter(check => 
              check.name.includes('Coverage') ||
              check.name.includes('Codecov')
            );
            
            const coveragePassed = coverageChecks.length === 0 || coverageChecks.every(c => 
              c.status === 'completed' && c.conclusion === 'success'
            );
            
            // Check E2E tests
            const e2eChecks = checks.data.check_runs.filter(check => 
              check.name.includes('E2E') ||
              check.name.includes('e2e') ||
              check.name.includes('Playwright')
            );
            
            const e2ePassed = e2eChecks.length === 0 || e2eChecks.every(c => 
              c.status === 'completed' && c.conclusion === 'success'
            );
            
            // Check for breaking changes label
            const labels = pr.data.labels.map(l => l.name);
            const hasBreakingChanges = labels.includes('breaking-change') || labels.includes('breaking');
            
            const status = {
              ci_cd: allCIPassed,
              staging_deployment: stagingDeployed,
              security_scan: securityPassed,
              code_coverage: coveragePassed,
              e2e_tests: e2ePassed,
              breaking_changes: hasBreakingChanges,
              ci_checks_count: ciChecks.length,
              security_checks_count: securityChecks.length,
              coverage_checks_count: coverageChecks.length,
              e2e_checks_count: e2eChecks.length
            };
            
            core.setOutput('status', JSON.stringify(status));
            core.setOutput('pr_number', prNumber.toString());
            
            return status;

      - name: Post DevOps Checklist (Non-Editable)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt('${{ steps.devops-status.outputs.pr_number }}');
            const status = JSON.parse('${{ steps.devops-status.outputs.status }}');
            
            // Get existing comments
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            
            const existingComment = comments.data.find(c => 
              c.user.type === 'Bot' && 
              c.body.includes('ğŸ”§ DevOps Checklist') &&
              c.body.includes('NON-EDITABLE')
            );
            
            const allPassed = status.ci_cd && 
                             status.staging_deployment && 
                             status.security_scan && 
                             status.code_coverage && 
                             status.e2e_tests;
            
            const comment = `## ğŸ”§ DevOps Checklist (NON-EDITABLE)

> âš ï¸ **This checklist is automatically managed by DevOps Bot. Manual edits will be overwritten.**

| # | Check | Status | Details |
|---|-------|--------|---------|
| **1** | **CI/CD Pipeline** | ${status.ci_cd ? 'âœ…' : 'â³'} | ${status.ci_cd ? 'All CI checks passed' : `${status.ci_checks_count} checks pending`} |
| **2** | **Staging Deployment** | ${status.staging_deployment ? 'âœ…' : 'â³'} | ${status.staging_deployment ? 'Deployed to staging' : 'Pending deployment'} |
| **3** | **Security Scan** | ${status.security_scan ? 'âœ…' : 'â³'} | ${status.security_scan ? 'Security checks passed' : `${status.security_checks_count} checks pending`} |
| **4** | **Code Coverage** | ${status.code_coverage ? 'âœ…' : 'â³'} | ${status.code_coverage ? 'Coverage checks passed' : `${status.coverage_checks_count} checks pending`} |
| **5** | **E2E Tests** | ${status.e2e_tests ? 'âœ…' : 'â³'} | ${status.e2e_tests ? 'E2E tests passed' : `${status.e2e_checks_count} checks pending`} |
| **6** | **Breaking Changes** | ${status.breaking_changes ? 'âš ï¸' : 'âœ…'} | ${status.breaking_changes ? 'Breaking changes detected' : 'No breaking changes'} |

---

### ğŸ“Š Summary

**Overall Status**: ${allPassed ? 'âœ… **READY FOR PRODUCTION**' : 'â³ **PENDING CHECKS**'}

**Completed**: ${[status.ci_cd, status.staging_deployment, status.security_scan, status.code_coverage, status.e2e_tests].filter(Boolean).length}/5

---

**âš ï¸ This checklist is automatically updated. Do not edit manually.**

*Last updated: ${new Date().toISOString()}*

---
*Automated by DevOps Checklist Bot*`;
            
            try {
              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: comment
                });
                console.log(`âœ… Updated DevOps checklist on PR #${prNumber}`);
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: comment
                });
                console.log(`âœ… Posted DevOps checklist on PR #${prNumber}`);
              }
            } catch (error) {
              console.log(`âš ï¸ Error posting comment: ${error.message}`);
            }

      - name: Create Required Check Run (Blocks Merge)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt('${{ steps.devops-status.outputs.pr_number }}');
            const status = JSON.parse('${{ steps.devops-status.outputs.status }}');
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const allPassed = status.ci_cd && 
                             status.staging_deployment && 
                             status.security_scan && 
                             status.code_coverage && 
                             status.e2e_tests;
            
            const completedCount = [
              status.ci_cd,
              status.staging_deployment,
              status.security_scan,
              status.code_coverage,
              status.e2e_tests
            ].filter(Boolean).length;
            
            // Create check run that blocks merging
            const checkRun = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'ğŸ”§ DevOps Checklist (Required)',
              head_sha: pr.data.head.sha,
              status: 'completed',
              conclusion: allPassed ? 'success' : 'failure',
              output: {
                title: allPassed ? 'âœ… DevOps Checklist Complete' : 'âŒ DevOps Checklist Incomplete',
                summary: `**DevOps Checklist Status**: ${completedCount}/5 checks completed\n\n${allPassed ? 'âœ… All DevOps requirements met. Ready for merge.' : 'âŒ DevOps requirements not met. Merge blocked.'}`,
                text: `## ğŸ”§ DevOps Checklist Status

| # | Check | Status |
|---|-------|--------|
| **1** | CI/CD Pipeline | ${status.ci_cd ? 'âœ… Passed' : 'âŒ Failed/Pending'} |
| **2** | Staging Deployment | ${status.staging_deployment ? 'âœ… Passed' : 'âŒ Failed/Pending'} |
| **3** | Security Scan | ${status.security_scan ? 'âœ… Passed' : 'âŒ Failed/Pending'} |
| **4** | Code Coverage | ${status.code_coverage ? 'âœ… Passed' : 'âŒ Failed/Pending'} |
| **5** | E2E Tests | ${status.e2e_tests ? 'âœ… Passed' : 'âŒ Failed/Pending'} |

### Summary

**Completed**: ${completedCount}/5

**Status**: ${allPassed ? 'âœ… **READY FOR MERGE**' : 'âŒ **MERGE BLOCKED**'}

${!allPassed ? '\nâš ï¸ **This PR cannot be merged until all DevOps checklist items pass.**\n' : ''}

---
*This check is required for merging. See PR comments for detailed status.*`
              }
            });
            
            console.log(`âœ… Created required check run: ${checkRun.data.id}`);
            console.log(`   Status: ${allPassed ? 'âœ… Passed' : 'âŒ Failed'}`);
            console.log(`   Conclusion: ${checkRun.data.conclusion}`);
            
            if (!allPassed) {
              core.setFailed(`DevOps Checklist incomplete: ${completedCount}/5 checks passed`);
            }

